<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF8">
        <meta name="discription" content="бла бла">
        <title>ADG-Project</title>
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <link rel="shortcut icon" href="../assets/favicon.ico" type="image/x-icon">
    </head>
    <body>
        <header>
            <div class="logo">ADG-Project</div>
            <address class="address">
                <p class="address__info">Автор: Авдеев Дмитрий Геннадьевич</p>
                <p class="address__info">Телефон: +79270111808</p>
                <p class="address__info">E-mail: adg.web@yandex.ru</p>
            </address>
        </header>
        <nav></nav>
        <main class="main">
            <section class="observers__section">
                <h1>Observers</h1>
            </section>
            <section class="observers__section">
                <h2>MutationObserver</h2>
                <p>По нажатию кнопок MutationObserver будет отлавливать изменения в элементе и вызывать callback-функцию. Тип изменения будет показан.</p>
                <div class="observers__mutation-wrapper">
                    <div class="observers__test-box-wrapper">
                        <div class="observers__test-box" contenteditable='true'>Измени текст</div>
                        <div class="observers__information"></div>
                    </div>
                    <div class="observers__buttons-wrapper">
                        <button class="observers__button observers__button_type_attribute">Изменить атрибут</button>
                        <button class="observers__button observers__button_type_element">Добавить элемент</button>
                        <button class="observers__button observers__button_type_text">Изменить текст</button>
                        <button class="observers__button observers__button_type_return">Вернуть к заводским настройкам)</button>
                    </div>
                </div>
            </section>
            <section class="observers__section">
                <h3>Config</h3>
                <p>Передается вторым аргументом в метод .observe(element, config)</p>
                <ul>
                    <li><strong>childList</strong> булево значение; наблюдать ли за изменениями за дочерними элементами этого элемента</li>
                    <li><strong>attributes</strong> булево значение; наблюдать ли за изменениями в атрибутах этого элемента</li>
                    <li><strong>characterData</strong> булево значение; наблюдать ли за изменениями данных или текстового содержания этого элемента</li>
                    <li><strong>subtree</strong> булево значение; наблюдать ли за изменениями за всеми вложенными элементами этого элемента, включая дочерние элементы, их дочерние элементы и т.п.</li>
                    <li><strong>attributeOldValue</strong> булево значение; если включено attributes, хотите ли вы захватить значение атрибута перед тем, как изменение будет записано</li>
                    <li><strong>characterDataOldValue</strong> булево значение; если включено <strong>characterData</strong>, хотите ли вы захватить значение данных перед тем, как изменение будет записано</li>
                    <li><strong>attributeFilter</strong> список атрибутов, за которыми нужно наблюдать, в квадратных скобках (пример: ['class','src'])</li>
                </ul>
                <h3>MutationRecord</h3>
                <ul>
                    <li><strong>type</strong> тип изменения: <strong>attribute</strong>, <strong>characterData</strong> или <strong>childList</strong></li>
                    <li><strong>target</strong> элемент, в котором произошло изменение</li>
                    <li><strong>addedNodes</strong> список (NodeList) элементов, атрибутов и текстовых узлов, добавленных к дереву</li>
                    <li><strong>removedNodes</strong> список (NodeList) элементов, атрибутов и текстовых узлов, удаленных из дерева</li>
                    <li><strong>previousSibling</strong> возвращает элемент находящийся на том же уровне DOM, что и данный непосредственно перед ним или null, если такового нет</li>
                    <li><strong>nextSibling</strong> возвращает элемент находящийся на том же уровне DOM, что и данный и следующий в дереве элементов непосредственно за ним или null, если такового нет</li>
                    <li><strong>attributeName</strong> имя измененного атрибута или атрибутов. Если установлена опция <strong>attributeFilter</strong>, то вернутся только отфильтрованные атрибуты</li>
                    <li><strong>oldValue</strong> значение до изменения в случае изменения атрибута или <strong>characterData</strong>; null для изменения типа <strong>childList</strong></li>
                </ul>
            </section>
            <section class="observers__section">
                <h2>Intersection Observer</h2>
                <h3>Запуск анимации</h3>
                <div class="observers__animation-wrapper">
                    <p class="observers__description">Описание: при скролле на 120px ниже блока, запустится анимация</p>
                    <div class="observers__animation">
                        <div class="observers__animation-item observers__animation-item"></div>
                    </div>
                </div>
                <div class="observers__images-wrapper">
                    <h3>Ленивая загрузка</h3>
                    <p>Картинки будут подгружаться при пересечении viewport на 120px (для наглядности)</p>
                    <p>
                        Картинки могут моргнуть, при обновлении страницы. Это из-за того что мне не захотелось заморачиваться с их размерами.
                        Прошу не обращать внимания)) Этого можно избежать, если изночально затаскивать в проект картинки с нужным размером,
                        а задавать размер в CSS.
                    </p>
                    <img class="observers__image" src="../assets/plug__head-with-glasses.svg" data-src="../assets/observers__image-cat.jpg" alt="picture with cat">
                    <img class="observers__image" src="../assets/plug__head-with-glasses.svg" data-src="../assets/observers__image-html.jpg" alt="picture about html and css">
                    <img class="observers__image" src="../assets/plug__head-with-glasses.svg" data-src="../assets/observers__image-code.jpg" alt="picture with lion and monkey">
                </div>

            </section>
            <section class="observers__section">
                <h3>Options</h3>
                <p>Передается вторым аргументом при инициализации new IntersectionObserver(function(){...}, options)</p>
                <ul>
                    <li>
                        <strong>root:</strong> Это корневой элемент, используемый для наблюдения. Он определяет базовую “область захвата” для
                        наблюдаемых элементов. По умолчанию, root — это viewport вашего браузера, но на самом деле это может быть любой элемент
                        в вашем DOM(в этом случае вы устанавливаете root как что-то вроде document.getElementById('your-element')). Имейте в виду,
                        что в этом случае элементы, за которыми вы хотите наблюдать, должны находиться внутри DOM-дерева root-элемента.
                    </li>
                    <li>
                        <strong>rootMargin:</strong> Это корневой элемент, используемый для наблюдения. Он определяет базовую “область захвата” для
                        наблюдаемых элементов. По умолчанию, root — это viewport вашего браузера, но на самом деле это может быть любой элемент в
                        вашем DOM(в этом случае вы устанавливаете root как что-то вроде document.getElementById('your-element')). Имейте в виду,
                        что в этом случае элементы, за которыми вы хотите наблюдать, должны находиться внутри DOM-дерева root-элемента.
                    </li>
                    <li>
                        <strong>threshold:</strong> Не всегда желательно реагировать на пересечение наблюдаемым элементом границы “области захвата”
                        (которая определяется комбинацией значений root и rootMargin) моментально. threshold задает процентное значение от такого
                        пересечения, на которое обсервер должен реагировать, Оно может быть задано как единичное значение или как массив значений.
                        Примеры:
                        <ul>
                            <li>
                                threshold: 0: IntersectionObserver с этим значением по-умолчанию должен реагировать, когда самый первый пиксель
                                наблюдаемого элемента пересечет одну из границ “области захвата”. Заметьте! IntersectionObserver отреагирует на
                                оба варианта: a) когда элемент входит и b) когда элемент покидает “область захвата”
                            </li>
                            <li>threshold: 0.5: Обсервер должен сработать, когда 50% от наблюдаемого элемента пересекает “область захвата”</li>
                            <li>threshold: [0, 0.2, 0.5, 1]: Обсервер должен реагировать в четырех случаях:
                                <ul>
                                    <li>
                                        Самый первый пиксель наблюдаемого элемента входит в «область захвата»: элемент на самом деле все еще
                                        не внутри этой области, либо самый последний пиксель покидает “область захвата”: элемент уже не внутри этой области;
                                    </li>
                                    <li>20% элемента внутри “области захвата”(еще раз, направление не имеет значения для IntersectionObserver);</li>
                                    <li>50% элемента внутри “области захвата”;</li>
                                    <li>100% элемента внутри “области захвата”. Это прямо противоположно значению threshold: 0</li>
                                </ul>
                            </li>
                        </ul>
                    </li>
                </ul>
                <p>
                    Во время загрузки страницы, использующей обсерверы, вы можете заметить, что колбек, переданный в IntersectionObserver вызван
                    по одному разу для всех наблюдаемых элементов. IntersectionObserver будет вызван для всех наблюдаемых элементов в момент их
                    регистрации, но это не значит, что все они пересекают нашу «область захвата». Это всего лишь означает, что экземпляр обсервера
                    для данного элемента был инициализирован и теперь управляется вашим IntersectionObserver.
                </p>
                <h3>IntersectionObserverEntry</h3>
                <p>Аргумент entries, который мы получаем в нашем колбеке — это массив, состоящий из элементов специального типа: IntersectionObserverEntry.</p>
                <ul>
                    <li>
                        <strong>rootBounds:</strong> прямоугольник, описывающий “область захвата”(root + rootMargin)
                    </li>
                    <li>
                        <strong>boundingClientRect:</strong> прямоугольник самого наблюдаемого элемента
                    </li>
                    <li>intersectionRect:</li> регион “области захвата”, пересеченный наблюдаемым элементом
                    <li>
                        <strong>isIntersecting:</strong> свойство, показывающее пересекает ли наблюдаемый элемент “область захвата” в данный момент или нет.
                        isIntersecting можно использовать, чтобы выяснить, входит ли наблюдаемый элемент в “область захвата” (true) или уже покидает ее (false).
                    </li>
                    <li>
                        <strong>intersectionRatio:</strong> параметр можно использовать для тех же целей, что и isIntersecting, но он дает значительно
                        больший контроль и точность, будучи числом с плавающей точкой, а не булевым значением.
                    </li>
                    <li>
                        <strong>target:</strong> оригинальный элемент, переданный в функцию observe() вашего обсервера. Вроде event.target.
                    </li>
                </ul>
                <p>Вторым параметром в callback передается self - это сам наблюдатель. <strong>new IntersectionObserver(function(ENTRIES, self) {…});</strong></p>
                <p>self.unobserve(entry.target) - убираем слежку за элементом. Нужно, чтобы избавится от лишнего шума, когда элемент уже загружен</p>
                <p>self.disconnect(entry.target) - полностью останавливает слежку (останавливает работу обсервера)</p>
            </section>
            <section class="observers__section">
                <a class="observers__link" href="../">На главную</a>
            </section>
        </main>
        <footer></footer>
    </body>
</html>